# 컴퓨터 프로그램의 구성
## 자료구조와 알고리즘
* 자료구조: 자료를 어떠한 방식으로 저장하느냐
* 알고리즘: 문제를 해결하기 위한 절차 카레 만드는 레시피?
* 자료구조 + 알고리즘 = 프로그래밍
* 예시) 최대값 탐색 알고리즘 = 배열(list) + 순차탐색

## 컴퓨터에서의 자료구조 (Data structure)
* 컴퓨터에서 자료를 정리하고 조직화하는 다양한 구조
* 자료구조에서 들어가는 구멍은 어떤 형태든지 하나다.

    |일상생활에서의 예|자료구조|
    |-------|------|
    |물건을 쌓아두는 것|스택|
    |영화관 매표소의 줄|큐|
    |할 일 리스트|리스트|
    |영어사전|사전, 탐색구조|
    |지도|그래프|
    |조직도|트리|

## 알고리즘 : 컴퓨터로 문제를 풀기 위한 단계적인 절차 
* ex) 전화번호부에서 특정 사람 이름 찾기
* 알고리즘의 조건

    |조건|내용|
    |---|---|
    |입력|0개 이상의 입력이 존재해야 한다|
    |출력|1개 이상의 출력이 존재하여야 한다|
    |명백성|각 명령어의 의미는 모호하지 않고 명확해야 함|
    |유한성|한정된 수의 단계 후에는 반드시 종료해야 함|
    |유효성|각 명령어들은 실행가능한 연산이어야 함|

    * 명백성 : '~를 해라'의 명령 주제가 뭔지
    * 유한성 : '~까지 해라'와 같이 종료 시점이 있어야 함
    * 유효성 : 연산 중에 말이 안되는 코드를 짰을 경우 에러 생김

### 알고리즘의 기술 방법
* 영어, 한국어와 같은 자연어
  * 인간이 읽기 쉽다
  * 단어가 정확히 정의되지 않으면 의미전달 모호해질 수 있음
* 흐름도(flow chart)
  * 직관적, 이해하기 쉬움
  * 복잡한 알고리즘의 경우에는 이해하기 어려워짐 -> 간단한 것들만 
* 유사 코드(pseudo-code)
  * 알고리즘의 고수준 기술 방법
  * 자연어보다 더 구조적
  * 프로그래밍보다는 덜 구체적
  * 알고리즘의 핵심적인 내용에만 집중
* 프로그래밍 언어 (파이썬, C언어, C++, java 등)
  * 알고리즘의 가장 정확한 기술 가능
  * 구현시 구체적인 사항이 알고리즘의 핵심 내용을 방해할 수 있음
    * 예시) 파이썬으로 표기된 알고리즘

## 자료형과 추상 자료형
### 추상화란?
* 어떤 시스템의 간략화된 기술 또는 명세
* 시스템의 정말 핵심적인 구조나 동작에만 집중. "무엇을 해라"를 말함. "어떻게?"는 말하지 않음

### 자료형(data type)
* 데이터의 집합과 연산의 집합(int, float... / 연산기호)

### 추상자료형(ADT: Abstract Data Type)
* 데이터 타입을 추상적(수학적)으로 정의한 것
* 데이터나 연산이 무엇(what)인가를 정의함
* 데이터나 연산을 어떻게(how) 구현할 것인지는 정의하지 않음

### 추상 자료형의 정의
* 자연수 ADT
* 데이터: 1에서 시작해 INT_MAX까지의 순서화된 정수의 부분 범위
* 연산

    |연산자|내용|
    |---|---|
    |add(x, y)|x + y가 INT_MAX보다 작으면 x + y 를 반환|
    |distance(x, y)|x가 y보다 크면 x-y를 반환, 아니면 y-x를 반환|

## 알고리즘의 성능분석
### 알고리즘의 성능 분석 기법
1. 실행 시간을 측정하는 방법
   * 실제 실행 시간을 측정하는 것
   * 실제로 구현하는 것이 필요함
   * 하드웨어(컴퓨터), 소프트웨어(프로그램언어)등의 환경에 따라 성능 달라짐
2. 알고리즘의 복잡도를 분석하는 방법
   * 직접 구현하지 않고 수행시간 분석함
   * 알고리즘이 수행하는 연산 횟수 측정
   * 시간 복잡도 분석 : 수행 시간 분석, 이것을 많이 사용함
   * 공간 복잡도 분석 : 수행시 필요로 하는 메모리 공간 분석(요즘은 사용하지 않음)

### 복잡도 분석하기
#### 시간 복잡도
* 기본적인 연산을 고려함
* 알고리즘의 수행에 필요한 연산 개수를 계산
* 입력의 개수 n에 대한 함수 -> 시간복잡도 함수 T(n)

* 알고리즘A(3n+2)와 알고리즘B(5n ^2^ + 6)을 비교해보면 알고리즘A가 시간복잡도가 좋다고 봄

### 복잡도 분석 예
* n을 n번 더하기 (for 루프 제어 연산은 고려하지 않음)
* 아래 표를 보면 알고리즘 A가 가장 빠름

    | |알고리즘 A|알고리즘 B|알고리즘 C|
    |---|---|---|---|
    |대입연산|1|n + 1| n*n + 1|
    |덧셈연산| |n|n*n|
    |곱셈연산|1| | |
    |나눗셈연산| | | 
    |전체연산수|2|2n+1|2n^2^ + 1|

### 수행시간의 점근표기법
* 다항식으로 구성, 이를 입력의 크기에 대한 함수로 표현하기 위해 점근표기법(Asymptotic Notation) 사용
* O (Big-Oh)-표기법
* Ω (Big-Omega)-표기법
* Θ (Theta)-표기법

#### O (Big-Oh)-표기법
* 상한(Upper Bound)표기법, 가장 큰 N의 항을 찾아 표기함
* 가장 큰 N항이 가장 큰 영향력을 가지기 때문에, 그 항의 계수를 제거하여 g(N)을 정함

#### Ω-표기법
* 하한(Lower Bound) 표기법, Big-Oh와 반대로 계산

#### Θ-표기법
* 상한과 하한의 중간표기법으로 생각하면 됨
* 실제값과 가장 유사한 증가율을 가짐

#### 자주 사용되는 함수의 O-표기와 이름
* 알고리즘의 수행시간은 주로 O-표기를 사용함
* 아래 표에 따르면, 표기법이 아래로 갈수록 시간이 오래 걸린다고 봄

    |표기법|뜻|
    |---|---|
    |O(1)|상수시간(Constant Time)|
    |O(logN)|로그(대수)시간(Logarithmic Time)|
    |O(N)|선형시간(Linear Time)|
    |O(NlogN)|로그선형시간(Log-linear Time)|
    |O(N2)|제곱시간(Quadratic Time)|
    |O(N3)|세제곱시간(Cubic Time)|
    |O(2N)|지수시간(Exponential Time)|

#### 최선, 평균, 최악의 경우
* 수행시간은 최선(Bast case)의 경우 잡는 것이 딱히 의미 없음
* 최악의 경우(Worst case), 수행시간이 가장 늦는 경우를 기준으로 하면 ㅈ호음
  * 가장 널리 사용됨
  * 계산하기 쉬움
  * 응용에 따라 중요한 의미를 가질 수 있음

